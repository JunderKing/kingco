###高性能Mysql
• ###Mysql架构与历史
    • ####Mysql逻辑架构
        • 连接处理、授权认证、安全等
        • Mysql核心服务功能：查询解析、分析、优化、缓存、内置函数等
        • 存储引擎：通过API与服务器通信
    • ####Mysql并发控制
        • 读写锁
            • 读锁(共享锁)：互相不阻塞
            • 写锁(排它锁)：一个写锁会阻塞其它写锁和读锁
        • 锁策略
            • 表锁(table lock)
                • 开销最小
                • 写锁可以插入到锁队列中读锁前面
                • 服务器层和存储引擎层都有实现
            • 行锁(row lock)
                • 最大程度支持并发，开销大
                • 只在存储引擎层实现
            • 死锁
                • 两个以上事务相互占用统一资源并请求锁定对方占用的资源
                • 死锁检测和死锁超时机制
                    • InnoDB检测到死锁并将持有最少行锁的事务回滚
    • ####Mysql事务
        • 事务内部的语句要么全部执行成功，要么全部失败
        • ACID：
            • 原子性(atomicity)
                • 一个事务必须是一个最小工作单元，要么全部执行成功，要么全部失败
            • 一致性(consistency)
                • 数据库总是从igest一致性状态转换到另一个一致性状态
            • 隔离性(isolation)
                • 一个事务的执行过程通常对其它事务是不可见的
                • read unconmitted(未读提交)
                    • 事务中的修改即使没有提交对其它事务也是可见的，又称为脏读(dirty read)
                    • 性能不会好太多，很少使用
                • read committed(提交读)
                    • 只能读取提交的事务所做的修改
                    • 其它数据库默认的隔离级别
                • repeatable read(可重复读)
                    • 同一个事务中多次读取同样的记录，结果是一致的，解决了脏读问题
                    • 无法解决幻读问题
                    • Mysql默认的隔离级别
                • serializable(可串行化)
                    • 在读取每一行数据上都加锁，导致大量超时和锁争用问题，实际很少使用
                    • 最高的隔离级别，强制事务串行执行，避免幻读问题
            • 持久性(durability)
                • 一旦事务提交，所有修改都会永久保存在数据库中
        • 事务日志
            • 修改表数据时只修改内存拷贝，再把修改行为记录到硬盘上的事务日志中。
            • 日志持久化之后，内存中被修改的数据在后台可以慢慢刷回到磁盘
            • 如果日志持久化，但数据没有写会磁盘，存储引擎会在重启后恢复这部分修改数据
            • 写日志采用追加方式，因此操作磁盘上一小块区域的顺序I/O而不是随机I/O，因此要快很多
        • Mysql中的事务
            • 自动提交(autocommit)
                • 每个查询都被当做一个事务提交
                • 当设置autocommit变量为0或者OFF的时候，所有查询都在一个事务中，直至执行COMMIT或ROLLBACK；结束的同时又开始一个新事务
                • 修改autocommit对非事务型的表(一直处于autocommit启用的模式)，比如MyISAM或内存表不会有任何影响
                • SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;设置当前会话隔离级别
            • 在事务中混合使用存储引擎
                • 服务器层不管理事务，由存储引擎实现
                • 如果在同一个事务中混合使用事务型和非事务型的表，回滚是会导致数据库不一致，很难修复
                • 有时候只有回滚非事务型的表才会发出一个警告
            • 显示和隐式锁定
                • 隐式锁定
                    • InnoDB在事务执行过程中随时可以执行锁定，只有在COMMIT或ROLLBACK时才被释放，所有锁在同一时刻被释放
                    • InnoDB会根据隔离级别在需要时自动加锁
                • 显示锁定
                    • InnoDB支持特定语句进行显示锁定，不属于SQL规范
                        • SELECT ... LOCK IN SHARE MODE
                        • SELECT ... FOR UPDATE
                • Mysql服务层支持LOCK TABLES和UNLOCK TABLES语句。会和事务相互影响，建议只在禁用AUTOCOMMIT时使用
    • ####多版本并发控制(MVCC => MultiVersion Concurrency Control)
        •  行锁变种，实现非阻塞读操作，写操作只锁定必要行；开销更低
        •  通过保存数据在某个时间点的快照实现
        •  仅在REPEABLE READ和READ COMMITED隔离级别下工作
        •  不同存储引擎的实现不同，有乐观并发控制和悲观并发控制
        •  InnoDB的MVVC
            •  每行记录保存两个隐藏的列，创建版本号和删除版本号，每开始一个事务版本号自动递增
            •  在REPEATABLE READ隔离级别下
                •  SELECT
                    •  行创建版本号小于等于事务版本号
                    •  行删除版本号要么未定义，要么大于当前事务版本号
                •  INSERT
                    •  为新插入数据每一行保存当前版本号为创建版本号
                •  DELETE
                    •  为删除的每一行保存当前版本号为删除版本号
                •  UPDATE
                    •  保存当前版本号作为创建版本号，当前版本号作为删除版本号
            •  大多数读操作不需要加锁，性能很好，符合隔离级别；需要额外的存储空间和行检查
    • ####Mysql存储引擎
        •  Mysql将每个数据库保存为数据目录(mysql)下的一个子目录，目录下tableName.frm文件保存表的定义
        •  因为Mysql使用文件系统的目录保存数据和表定义，因此大小写是否敏感跟平台密切相关：Windows中不敏感，类Unix中敏感
        •  不同存储引擎保存数据和索引的方式不同，但表的定义在服务层统一处理
        •  SHOW TABLE STATUS查看表相关信息
        •  InnoDB存储引擎
            •  Mysql默认的事务型存储引擎，也是最重要、最广泛的存储引擎
            •  数据存储在表空间中（由InnoDB管理的一个黑盒子）
            •  采用MVCC支持高并发，实现了四个标准的隔离级别，默认级别为可重复读
            •  通过间隙锁（next-key locking）防止幻读
            •  基于聚簇索引建立表，对主键查询有很高性能，不过二级索引必须包含主键列
        • 转换表的引擎
            • ALTER TABLE $tableName ENGINE = InnoDB;
                • 按行将原表数据复制到新表，原表加上读锁，需要执行很长时间
                • InnoDB->MyISAM->InnoDB，所有的外键将丢失
            • mysqldump将数据导出=>修改文件中CREATE TABLE语句中存储引擎的选择，同时修改表名
            • 创建和插入
                • CREATE TABLE innodb_table LIKE myisam_table;
                • ALTER TABLE innodb_table ENGINE=InnoDB;
                • INSERT INTO innodb_table SELECT * FROM myisam_table;
                • 如果数据量大可以考虑分批执行
                • 可以在执行过程中对原表格加锁，确保数据一致
• Mysql基准
• 服务器性能
• Schema与数据类型优化
• 创建高性能索引
• 查询性能优化
• Mysql高级特性
• 优化服务器设置
• 操作系统和硬件优化
• 复制可
• 扩展的Mysql
• 高可用性
• 云端Mysql
• 应用层优化
• 备份与恢复
• Mysql用户工具
